#! /usr/bin/ruby

if RUBY_VERSION < "1.8.7"
    STDERR.puts "autoproj requires Ruby >= 1.8.7"
    exit 1
end

needed_gem_home = ENV['AUTOPROJ_GEM_HOME'] || "#{Dir.pwd}/.gems"
if $LOADED_FEATURES.find { |str| str =~ /bygems/ }
    if ENV['GEM_HOME'] != needed_gem_home
        require 'rbconfig'
        RUBY = RbConfig::CONFIG['RUBY_INSTALL_NAME']

        ENV['GEM_HOME'] = needed_gem_home
        exec RUBY, __FILE__, *ARGV
    end
end


ENV['GEM_HOME'] = needed_gem_home
ENV['PATH']     = "#{ENV['GEM_HOME']}/bin:#{ENV['PATH']}"

require 'yaml'
require 'set'

module Autoproj
    class ConfigError < RuntimeError; end
    class << self
        attr_reader :verbose
        attr_reader :config
    end
    @config = Hash.new

    # Fake option management for the OSdeps class
    def self.has_config_key?(key)
        config.has_key?(key)
    end

    def self.user_config(key)
        config[key]
    end

    def self.change_option(name, value, ignored = true)
        config[name] = value
    end

    def self.color(string, *args)
        string
    end
end

module Autobuild
    def self.do_update
        true
    end
    def self.progress(str)
        STDERR.puts "  #{str}"
    end

    class << self
        attr_reader :programs
    end
    @programs = Hash.new
    def self.tool(name)
        # Let the ability to set programs[name] to nil to make sure we don't use
        # that program. This is used later on in this file to make sure we
        # aren't using the wrong rubygems binary
        if programs.has_key?(name)
            programs[name]
        else
            name
        end
    end

    module Subprocess
        def self.run(name, phase, *cmd)
            output = `#{cmd.join(" ")}`
            if $?.exitstatus != 0
                STDERR.puts "ERROR: failed to run #{cmd.join(" ")}"
                STDERR.puts "ERROR: command output is: #{output}"
                exit 1
            end
        end
    end
end

OSDEPS_CODE

DEFS = <<EODEFS
OSDEPS_DEFAULTS
EODEFS

if ENV['AUTOPROJ_AUTOMATIC_OSDEPS']
    automatic_osdeps = ENV['AUTOPROJ_AUTOMATIC_OSDEPS']
else
    operating_system = Autoproj::OSDependencies.operating_system
    if !operating_system
        puts <<-EOT

    autoproj is usually able to handle the installation of operating system packages
    himself. However, it does not know about your operating system, and will
    therefore have to let you install the packages yourself.

    It can still install the RubyGems packages that are required by the built
    packages.

    If you answer 'no' to the following question, autoproj will always go on,
    assuming that all the required dependencies are already installed. If you answer
    'yes', it will make sure that the RubyGems are installed himself, but it will
    assume that you took care of the other packages. If you answer 'wait', it will
    not install anything but will wait for you to press ENTER each time some
    external software is needed. Finally, if you answer 'ask', it will ask you each
    time what it should do when there is something to install

        EOT

        print "How should autoproj install RubyGems packages automatically (yes, no, wait or ask) ? [yes] "
        STDOUT.flush
    else
        # Before doing *anything*, we have to ask the user if he wants us to install
        # the osdeps ...
        puts <<-EOT

    autoproj is able to handle the installation of operating system packages
    himself. This functionality will use 'sudo' to gain root access each time
    it is needed.

    If you answer 'no' to the following question, autoproj will go on, assuming that
    all the required dependencies are already installed. If you answer 'yes', it
    will make sure that they are installed himself. If you answer 'wait', it will
    not install anything but wait for you to press ENTER each time some external
    software is needed.  Finally, if you answer 'ask', it will ask you what it
    should do each time there is something to install.

        EOT
        print "Should autoproj install OS packages automatically (yes, no, wait or ask) ? [yes] "
        STDOUT.flush
    end

    automatic_osdeps = nil
    while automatic_osdeps.nil?
        answer = STDIN.readline.chomp
        if answer == ''
            automatic_osdeps = true
        elsif answer == "no"
            automatic_osdeps = false
        elsif answer == 'ask'
            automatic_osdeps = :ask
        elsif answer == 'yes'
            automatic_osdeps = true
        else
            print "invalid answer. Please answer with 'yes', 'no' or 'ask' "
            STDOUT.flush
        end
    end
end

Autoproj.config['automatic_osdeps'] =
    automatic_osdeps

# First thing we do is install a proper ruby environment. We make sure that we
# aren't installing any gems for now (as we need to choose the right gem
# binary) by setting Autobuild.programs['gem'] to nil
Autobuild.programs['gem'] = nil
Autoproj::OSDependencies.autodetect_ruby

begin
    osdeps_management = Autoproj::OSDependencies.new(YAML.load(DEFS))
    STDERR.puts "autoproj: installing a proper Ruby environment (this can take a long time)"
    osdeps_management.install(['ruby'])
rescue Autoproj::ConfigError => e
    STDERR.puts "failed: #{e.message}"
    exit(1)
end

# Now try to find out the name of the gem binary
PACKAGES      = %w{rdoc libxml2 libxslt zlib build-essential lsb_release}
USER_PACKAGES = %w{autoproj}

ENV['RUBYOPT']  = "-rubygems"
require 'rubygems'

packages = PACKAGES + USER_PACKAGES

begin
    osdeps_management = Autoproj::OSDependencies.new(YAML.load(DEFS))
    STDERR.puts "autoproj: installing autoproj and its dependencies (this can take a long time)"
    osdeps_management.install(packages)
rescue Autoproj::ConfigError => e
    STDERR.puts "failed: #{e.message}"
    exit(1)
end

if ARGV.first == "dev"
    Autoproj::OSDependencies.gem_with_prerelease = true
end
end

File.open('env.sh', 'w') do |io|
    io.write <<-EOSHELL
export RUBYOPT=-rubygems
export GEM_HOME=#{needed_gem_home}
export PATH=$GEM_HOME/bin:$PATH
    EOSHELL
end

ENV['AUTOPROJ_AUTOMATIC_OSDEPS'] = automatic_osdeps.to_s
if !system('autoproj', 'bootstrap', *ARGV)
    STDERR.puts "ERROR: failed to run autoproj bootstrap #{ARGV.join(", ")}"
    exit 1
end

