#! /usr/bin/env ruby

require 'rubotics'
require 'rubotics/autobuild'

require 'highline'
include Rubotics

InputError = Rubotics::InputError
module Rubotics
    @verbose = false
    @console = HighLine.new

    class << self
        attr_accessor :verbose
        attr_reader :console
    end
end

class RuboticsReporter < Autobuild::Reporter
    def error(error)
        error_lines = error.to_s.split("\n")
        STDERR.puts color("Build failed: #{error_lines.shift}", :bold, :red)
        STDERR.puts error_lines.join("\n")
    end
    def success
        STDERR.puts color("Build finished successfully at #{Time.now}", :bold, :green)
        if Autobuild.post_success_message
            puts Autobuild.post_success_message
        end
    end
end

def tail(file, count)
    lines = File.readlines(file)
    if lines.size < count
        lines
    else
        lines[-count, count]
    end
end

# Find the rubotics root dir
root_dir = Rubotics.root_dir

Rubotics.load_config

# Set up some important autobuild parameters
Autobuild.prefix  = Rubotics.build_dir
Autobuild.srcdir  = root_dir
Autobuild.doc_errors = false
Autobuild.do_doc = false
debug = false
Autobuild::Reporting << RuboticsReporter.new

# Parse the configuration options
mail_config = Hash.new
parser = OptionParser.new do |opts|
    opts.banner = <<-EOBANNER
rubotics mode [options]
where 'mode' is one of:
  build:  import, build and install all selected packages
  doc:    generate and install documentation for packages that have some
  update: only import/update packages, do not build them
  status: displays the state of the packages w.r.t. their source VCS
  
  list-sources:   list all available sources
  update-sources: update all remote sources, but do not build

Additional options:
    EOBANNER
    opts.on("--reconfigure", "re-ask all configuration options (build mode only)") do
        Rubotics.reconfigure = true
    end
    opts.on("--no-update", "do not update already checked-out sources (build mode only)") do
        Autobuild.do_update = false
    end

    opts.on("--verbose", "verbose output") do
        Rubotics.verbose  = true
        Autobuild.verbose = true
        Rake.application.options.trace = false
    end
    opts.on("--debug", "debugging output") do
        Rubotics.verbose  = true
        Autobuild.verbose = true
        Rake.application.options.trace = true
        debug = true
    end
    opts.on('--nice NICE', Integer, 'nice the subprocesses to the given value') do |value|
        Autobuild.nice = value
    end
    opts.on("-h", "--help", "Show this message") do
        puts opts
        exit
    end
    opts.on("--mail-from EMAIL", String, "From: field of the sent mails") do |from_email|
        mail[:from] = from_email
    end
    opts.on("--mail-to EMAILS", String, "comma-separated list of emails to which the reports should be sent") do |emails| 
        mail[:to] ||= []
        mail[:to] += emails.split(',')
    end
    opts.on("--mail-subject SUBJECT", String, "Subject: field of the sent mails") do |subject_email|
        mail[:subject] = subject_email
    end
    opts.on("--mail-smtp HOSTNAME", String, " address of the mail server written as hostname[:port]") do |smtp|
        raise "invalid SMTP specification #{smtp}" unless smtp =~ /^([^:]+)(?::(\d+))?$/
            mail[:smtp] = $1
        mail[:port] = Integer($2) if $2 && !$2.empty?
    end
    opts.on("--mail-only-errors", "send mail only on errors") do
        mail[:only_errors] = true
    end
end

args = ARGV.dup
parser.parse!(args)
mode     = args.shift
packages = args
only_update_sources = false

case mode
when "bootstrap"
    sample_dir = File.expand_path(File.join("..", "samples"), File.dirname(__FILE__))
    FileUtils.mkdir_p "rubotics"
    FileUtils.cp File.join(sample_dir, "manifest"), "rubotics"
    exit 1

when "build"
when "update"
    Autobuild.do_build  = false
when "status"
    only_do_status      = true
    Autobuild.do_update = false
when "update-sources"
    only_update_sources = true
when "list-sources"
    only_update_sources = true
    Autobuild.do_update = false
    
when "doc"
    Autobuild.do_update = false
    Autobuild.do_doc    = true
    Autobuild.only_doc  = true
else
    puts parser
    exit(1)
end

def color(*args)
    Rubotics.console.color(*args)
end

if mail_config[:to]
    Autobuild::Reporting << MailReporter.new(mail_config)
end

def do_status(packages)
    console = Rubotics.console

    Autobuild::Reporting.report do
        packages.sort.each do |pkg|
            pkg = Autobuild::Package[pkg]

            STDERR.print "#{pkg.name}:"

            if !pkg.importer.respond_to?(:status)
                # This importer does not support status display
                STDERR.puts color("  this package's importer does not support status display", :bold, :red)
                next
            end

            lines = []
            status = pkg.importer.status(pkg)
            if status.uncommitted_code
                lines << color("  contains uncommitted modifications", :red)
            end

            case status.status
            when Autobuild::Importer::Status::UP_TO_DATE
                lines << color("  local and remote are in sync", :green)
            when Autobuild::Importer::Status::ADVANCED
                lines << color("  local contains #{status.local_commits.size} commit that remote does not have:", :magenta)
                status.local_commits.each do |line|
                    lines << color("    #{line}", :magenta)
                end
            when Autobuild::Importer::Status::SIMPLE_UPDATE
                lines << color("  remote contains #{status.remote_commits.size} commit that local does not have:", :magenta)
                status.remote_commits.each do |line|
                    lines << color("    #{line}", :magenta)
                end
            when Autobuild::Importer::Status::NEEDS_MERGE
                lines << color("  local and remote have diverged with respectively #{status.local_commits.size} and #{status.remote_commits.size} commits each", :magenta)
                lines << "  -- local commits --"
                status.local_commits.each do |line|
                    lines << color("   #{line}", :magenta)
                end
                lines << "  -- remote commits --"
                status.remote_commits.each do |line|
                    lines << color("   #{line}", :magenta)
                end
            end

            if lines.size == 1
                STDERR.puts lines.first
            else
                STDERR.puts
                STDERR.puts lines.join("\n")
            end
        end
    end
end

# Set the initial environment
Rubotics.set_initial_env
begin
    Dir.chdir(root_dir) do
        # Load the manifest
        manifest = Rubotics.manifest = Manifest.load(File.join('rubotics', 'manifest'))
        source_os_dependencies = manifest.each_remote_source(false).
            inject(Set.new) do |set, source|
                set << source.vcs.type if !source.local?
            end

        if !source_os_dependencies.empty?
            STDERR.puts color("rubotics: installing prepackaged dependencies to access the source definitions", :bold)
            osdeps = manifest.known_os_packages
            osdeps.install(source_os_dependencies)
        end
        if manifest.has_remote_sources?
            STDERR.puts color("rubotics: updating remote sources", :bold)
            Autobuild::Reporting.report do
                manifest.update_remote_sources
            end
            STDERR.puts
        end

        # If in verbose mode, or if we only update sources, list the sources
        if Rubotics.verbose || only_update_sources
            STDERR.puts color("rubotics: available sources", :bold)
            manifest.each_source(false) do |source|
                STDERR.puts "  #{source.name}"
                if source.local?
                    STDERR.puts "    local source in #{source.local_dir}"
                else
                    STDERR.puts "    vcs:   #{source.vcs}, #{source.vcs.options.inspect}"
                    STDERR.puts "    local: #{source.local_dir}"
                end
            end
        end
        if only_update_sources
            exit(0)
        end

        # Load init.rb files. each_source must not load the source.yml file, as
        # init.rb may define configuration options that are used there
        manifest.each_source(false) do |source|
            init_rb = File.join(source.local_dir, "init.rb")
            if File.exists?(init_rb)
                load init_rb
            end
        end

        # Load the required autobuild definitions
        STDERR.puts color("rubotics: loading build files and configuring build", :bold)
        if !Rubotics.reconfigure?
            STDERR.puts color("run 'rubotics --reconfigure' to change configuration values", :bold)
        end
        manifest.each_autobuild_file do |source, name|
            if Rubotics.manifest.enabled_source?(source)
                Rubotics.import_autobuild_file source, name
            end
        end

        Rubotics.save_config

        # Now, load the package's importer configurations
        manifest.load_importers

        if Rubotics.verbose
            # List defined packages, and in which autobuild files they are defined
            STDERR.puts "Available packages:"
            Rubotics.manifest.packages.each_value do |package, source, file|
                STDERR.puts "  #{package.name}: #{file} from #{source.name}"
            end
        end

        # Create the build target from the manifest if the user did not provide an
        # explicit one
        if packages.empty?
            enabled_sources = Rubotics.manifest.enabled_sources
            packages = manifest.packages.values.map do |package, source, _|
                package.name if Rubotics.manifest.enabled_source?(source)
            end.compact
        end

        if packages.empty?
            STDERR.puts
            STDERR.puts color("rubotics: no packages defined", :red)
            exit 0
        end

        if Rubotics.verbose
            STDERR.puts "will install #{packages.join(", ")}"
        end

        STDERR.puts
        STDERR.puts color("rubotics: installing prepackaged dependencies for build system & version control", :bold)
        osdeps = manifest.known_os_packages
        osdeps.install(Rubotics.build_system_dependencies - source_os_dependencies)

        # We are doing a status, so do it now
        STDERR.puts
        if only_do_status
            do_status(packages)
            exit 0
        end

        # Do the import, so that we can load the manifests
        STDERR.puts
        STDERR.puts color("rubotics: updating packages", :bold)
        Autobuild::Reporting.report do
            import_targets = packages.map { |pkg| "#{pkg}-import" }
            task "rubotics-import" => import_targets
            Rake::Task["rubotics-import"].invoke
        end

        # Load package manifests, apply dependencies to the autobuild definitions
        # and install OS packages
        pkg_manifests = []
        manifest.each_package do |pkg|
            pkg_manifests << File.join(pkg.srcdir, "manifest.xml")
        end
        manifest.load_package_manifests
        STDERR.puts
        STDERR.puts color("rubotics: installing prepackaged dependencies required by the packages", :bold)
        manifest.install_os_dependencies

        # And now build
        STDERR.puts
        if Autobuild.only_doc
            STDERR.puts color("rubotics: building and installing documentation", :bold)
        else
            STDERR.puts color("rubotics: building and installing packages", :bold)
        end

        Autobuild::Reporting.report do
            Autobuild.apply(packages)
            STDERR.puts
            Autobuild::Reporting.success
        end

        Rubotics.export_env_sh
    end
rescue ConfigError => e
    STDERR.puts
    STDERR.puts color(e.message, :red, :bold)
    raise if debug
rescue Interrupt
    STDERR.puts
    STDERR.puts color("Interrupted by user", :red, :bold)
    raise if debug
end

