#! /usr/bin/env ruby

if RUBY_VERSION < "1.8.7"
    STDERR.puts "autoproj requires Ruby >= 1.8.7"
    exit 1
end

require 'autoproj'
require 'autoproj/autobuild'
require 'open-uri'
require 'autoproj/cmdline'

include Autoproj

InputError = Autoproj::InputError

def color(*args)
    Autoproj.console.color(*args)
end

def report
    Autobuild::Reporting.report do
        yield
    end
    Autobuild::Reporting.success

rescue ConfigError => e
    STDERR.puts
    STDERR.puts color(e.message, :red, :bold)
    if Autoproj.in_autoproj_installation?(Dir.pwd)
        root_dir = /^#{Regexp.quote(Autoproj.root_dir)}(?!\/\.gems)/
        e.backtrace.find_all { |path| path =~ root_dir }.
            each do |path|
                STDERR.puts color("  in #{path}", :red, :bold)
            end
    end
    if Autobuild.debug then raise
    else exit 1
    end
rescue Interrupt
    STDERR.puts
    STDERR.puts color("Interrupted by user", :red, :bold)
    if Autobuild.debug then raise
    else exit 1
    end
end

Autoproj::OSDependencies.autodetect_ruby

# Find the autoproj root dir
report do
    selected_packages =
        begin Autoproj::CmdLine.parse_arguments(ARGV.dup)
        rescue RuntimeError => e
            if Autoproj::CmdLine.bootstrap? && !Autoproj.in_autoproj_installation?(Dir.pwd)
                STDERR.puts <<EOTEXT


#{color('autoproj bootstrap failed', :red, :bold)}
To retry, first source the env.sh script with
  source #{Dir.pwd}/env.sh
and then re-run autoproj bootstrap with
  autoproj bootstrap <vcs_type> <vcs_url> <vcs_options>

where
  'vcs_type' is git, svn, darcs, cvs
  'vcs_url' is the vcs-specific URL to the repository, and
  'vcs_options' are optional values that can be given to the chosen VCS
EOTEXT
            end
            raise
        end

    # Expand directories in the selected_packages set, before we chdir to the
    # autoproj root
    root_dir = Autoproj.root_dir
    selected_packages.map! do |name|
        if File.directory?(name)
            File.expand_path(name)
        else
            name
        end
    end

    Dir.chdir(root_dir)

    # Basic initialization
    Autoproj::CmdLine.initialize
    if selected_packages.empty?
        Autoproj::CmdLine.update_myself
        Autoproj::CmdLine.update_configuration
    end
    Autoproj::CmdLine.load_configuration
    manifest = Autoproj.manifest

    # Once thing left to do: handle the Autoproj.auto_update configuration
    # parameter
    #
    # Namely, we must check if Autobuild.do_update has been explicitely set to
    # true or false. If that is the case, don't do anything. Otherwise, set it
    # to the value of Autoproj.auto_update
    if Autobuild.do_update.nil?
        Autobuild.do_update = Autoproj.auto_update?
    end

    Autoproj::CmdLine.initial_package_setup
    resolved_selected_packages = Autoproj::CmdLine.resolve_user_selection(selected_packages)
    if !selected_packages.empty?
        command_line_selection = resolved_selected_packages.dup
    else
        command_line_selection = Array.new
    end
    Autoproj.manifest.explicit_selection = resolved_selected_packages
    selected_packages = resolved_selected_packages

    # If in verbose mode, or if we only update sources, list the sources
    if Autoproj.verbose || Autoproj::CmdLine.display_configuration?
        Autoproj::CmdLine.display_configuration(manifest, selected_packages)
    end
    
    if Autoproj::CmdLine.bootstrap?
        STDERR.puts <<EOTEXT


#{color('autoproj bootstrap successfully finished', :green, :bold)}

#{color('To further use autoproj and the installed software', :bold)}, you
must add the following line at the bottom of your .bashrc:
  source #{Dir.pwd}/env.sh

WARNING: autoproj will not work until your restart all
your consoles, or run the following in them:
  $ source #{Dir.pwd}/env.sh

#{color('To import and build the packages', :bold)}, you can now run
  autoproj update
  autoproj build

The resulting software is installed in
  #{Dir.pwd}/install

EOTEXT
    end

    if Autoproj::CmdLine.only_config? || Autoproj::CmdLine.reconfigure?
        exit(0)
    end

    if Autoproj::CmdLine.only_status?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.status(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.check?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.check(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.manifest_update?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.manifest_update(all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.snapshot?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.snapshot(Autoproj::CmdLine.snapshot_dir, all_enabled_packages)
        exit(0)
    elsif Autoproj::CmdLine.revshow_osdeps?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.revshow_osdeps(all_enabled_packages)
    elsif Autoproj::CmdLine.show_osdeps?
        all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)
        Autoproj::CmdLine.show_osdeps(all_enabled_packages)
    end

    STDERR.puts
    STDERR.puts color("autoproj: importing and loading selected packages", :bold)

    # Install prepackaged dependencies needed to import and build the packages.
    # The required information is in the package sets configuration.
    if Autoproj::CmdLine.update_os_dependencies?
        Autoproj.osdeps.install(Autoproj.build_system_dependencies)
    end

    # Now, we actually do the import. Unfortunately, at this stage, we need to
    # import the package and its dependencies ourselves so that we are able to
    # build the list of packages that have actually been selected on the command
    # line.
    all_enabled_packages = Autoproj::CmdLine.import_packages(selected_packages)

    if Autoproj::CmdLine.update_os_dependencies? && !all_enabled_packages.empty?
        begin
            update_mode = Autobuild.do_update
            Autobuild.do_update ||= Autoproj::CmdLine.osdeps?
            manifest.install_os_dependencies(all_enabled_packages)
        ensure
            Autobuild.do_update = update_mode
        end
    end

    if all_enabled_packages.empty?
        STDERR.puts color("autoproj: nothing to do", :bold)
    elsif Autoproj::CmdLine.doc?
        Autoproj::CmdLine.build_packages(command_line_selection, all_enabled_packages)
    elsif Autoproj::CmdLine.build? 
        Autoproj::CmdLine.build_packages(command_line_selection, all_enabled_packages)

        # Now, do some sanity checks on the result
        prefixes = all_enabled_packages.inject(Set.new) do |set, pkg_name|
            set << Autobuild::Package[pkg_name].prefix
        end

        Autoproj.progress
        Autoproj.progress "checking for undefined symbols in installed libraries", :bold
        prefixes.each do |prefix|
            libdir = File.join(prefix, "lib")
            if File.directory?(libdir)
                Autoproj.validate_solib_dependencies(libdir)
            end
        end
    end

    if Autoproj::CmdLine.update_envsh?
        Autoproj.export_env_sh
        Autoproj.progress "autoproj: updated #{Autoproj.root_dir}/env.sh", :green
    end

    if Autoproj::CmdLine.show_statistics?
        per_phase = Hash.new
        per_type  = Hash.new

        Autoproj.progress
        Autoproj.progress "statistics about the build", :bold

        Autoproj.manifest.each_package.sort_by(&:name).each do |pkg|
            next if pkg.statistics.empty?

            if per_phase.empty?
                Autoproj.progress "detailed per package"
            end

            puts "  #{pkg.name}: %.1fs" % [pkg.statistics.values.inject(&:+)]
            pkg.statistics.each_key.sort.each do |phase|
                per_phase[phase] ||= 0
                per_phase[phase] += pkg.statistics[phase]
                per_type[pkg.class] ||= Hash.new
                per_type[pkg.class][phase] ||= 0
                per_type[pkg.class][phase] += pkg.statistics[phase]
                puts "    #{phase}: %.1fs" % [pkg.statistics[phase]]
            end
        end

        if !per_type.empty?
            Autoproj.progress
            Autoproj.progress "detailed per package type"
            per_type.each do |pkg_type, phases|
                Autoproj.progress "  #{pkg_type.name}: %.1fs" % [phases.values.inject(&:+)]
                phases.each_key.sort.each do |phase_name|
                    Autoproj.progress "    #{phase_name}: %.1fs" % [phases[phase_name]]
                end
            end
        end

        if !per_phase.empty?
            Autoproj.progress
            Autoproj.progress "summary per phase"
            per_phase.keys.sort.each do |phase_name|
                Autoproj.progress "  #{phase_name}: %.1fs" % [per_phase[phase_name]]
            end
        end
    end
end

